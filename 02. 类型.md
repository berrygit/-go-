# 1. 类型

类型指变量的类别，规定了变量包含的信息、存储格式、以及具有的功能，go有四种类型：

- **基本类型**
- **复合类型**
- **引用类型**
- **接口类型**

类型的声明方式：`type name underlying-type`，如

```go
type month int
```

基于已有类型定义新的类型，相当于对已有类型定义了别名，所以对于底层使用相同类型的情况，可以将一个变量从一种类型转换为另一种类型，方式为：`类型A(类型B的变量)`，如

```go
type A int
type B int
var a A = 1
var b B = B(a)
```

# 2. 基本类型

基本类型是go语言预先定义好的基础类型，编程者可以基于这些类型完成基本的功能，也可以用基本类型构建出更加复杂的自定义的复合类型。

## 2.1 整型

go对于数字有多种类型，区别在于存储数据的长度以及是否需要区分符号，可按需使用

- 有符号整型有4种长度：`int8，int16，int32，int64`
- 无符号整型类似有：`uint8，uint16，uint32，uint64`

存在更加通用的有符号整型类型`int`，但是在不同平台实现下底层占用的位数无法保证（一般是32位或64位）

## 2.2 浮点型

go浮点型有两种：`float32, float64`

## 2.3 布尔型

go布尔型为：`bool`，取值为`true\false`

## 2.4 字符串

### 声明方式

go的字符串类型为`string`，声明字符串有两种方式:
- 使用双引号，可以包含转义字符（以`\`标记），如:
```go
var content string = "hello world\n"
```
- 使用`引号，无法包含转义字符，引号内的全部内容均会被原封不动记录，可以跨越多行，如:
```go
var content string = `hello
world`
```

### 字符集

编码是将一个事物数字化，字符集编码是将文字数字化，规定了一个文字在硬件层面的编码值。定义好编码规则后，不同程序按照相同的编码规则处理信息发送和接收，便可正常的完成信息传递。如当一个字符串在存储到硬件层面会将每个字符编码成二进制，读取时再将二机制编码恢复成文字即可。

常用的字符集有：
- **ASCII**,使用一个字节（7位）存储字符（长度固定），只覆盖到英文常用的128个字符（英文字母及大小写，数字，特殊字符等）
- **unicode**,使用4个字节（32位）存储字符（长度固定），覆盖世界全部语言中的文字
- **UTF-8**,可变长度，解决了ASCII覆盖字符过小的问题，同时解决Unicode对于高频使用的字符都用32位存储浪费存储空间的问题

![image](https://github.com/berrygit/fast-start-golang/assets/13058540/cd96398b-7243-4f65-a440-7e057cdd70c7)

注：图片来自维基百科

go语言源代码使用utf-8字符集遍写，如果想要对一个字符串里的字符单独处理，需要将其转换为unicode编码的字符，go语言里将字符称为rune，如：
```go
package main

import "fmt"

func main() {
	for _, char := range []rune("abc世界") {
		fmt.Printf("%q\n", char)
	}
	for _, char := range "abc世界" {           // for循环里可省略字符转rune的过程，直接使用
		fmt.Printf("%q\n", char)
	}
}
```

### 陷阱
使用内建函数`len`获取字符串的长度，返回的是字符串实际占用字节的个数，而非字符的个数，如：
```go
package main

import "fmt"

func main() {
	fmt.Println(len("abc世界"))
}
```

## 2.5类型转换

对于不同的基础类型，go语言不提供隐式自动转换，需要显示声明

- 对于数字类型，如果目标类型范围更大，转换一般不会出现问题，如果目标类型范围变小，转换将会丢失精度，如：
  ```go
package main

import "fmt"

func main() {
	var num1 int8 = 1
	fmt.Println(int64(num1))    // 转换到更高的容量
	var num2 int32 = 2
	fmt.Println(int16(num2))
	var num3 float32 = 3.14
	fmt.Println(int8(num3))     // 转换到低精度，将丢失信息
}
  ```
- 对于数字与字符相互转换，无法强制转换，需要通过strconv工具包实现，如：
```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var num1 int8 = 1
	fmt.Println(strconv.Itoa(int(num1)))            // int型转字符串
	fmt.Println(strconv.FormatInt(int64(num1), 10)) // 更通用的方法
	var num2 = "123"
	fmt.Println(strconv.Atoi(num2))             // 字符串转int类型
	fmt.Println(strconv.ParseInt(num2, 10, 64)) // 更通用的方法
}
```
- 并不是所有类型之间均可转换，如：
  ```go
  package main

import (
	"fmt"
)

func main() {
	var num1 int8 = 1
	fmt.Println(bool(num1)) // 数字无法转布尔
	var num2 = "123"
	fmt.Println(int64(num2)) // 字符串无法转数字
}
  ```


# 3. 复合类型

## 结构体
由不同类型的值组成

## 切片
切片不是引用类型
## map
map是引用类型

# 4. 引用类型

引用类型包括：指针，切片，map，函数，通道。

**指针**

指针是变量的地址，变量一定有对应的指针，指针通过`&`获取，如

```go
var x int         // x是变量
p := &x           // p是变量x的指针（地址），p的类型为*int
fmt.Println(*p)   // 可以通过*p获取指针指向地址保存的内容，也就是x的值
```

在go语言中，指针存在的主要作用是用来解决函数调用时值传递的问题，提供一种手段跨函数修改变量中的内容。

# 5. 接口类型


# 常量
常量的类型只能是数字、字符串或布尔

